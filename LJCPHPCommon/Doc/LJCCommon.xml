<?xml version="1.0" encoding="utf-8" ?>
<!-- Copyright (c) Lester J. Clark 2022 - All Rights Reserved -->
<!-- LJCCommon.xml -->
<items>
  <!-- The XML file for the first file class contains the library comments. -->
  <LJCCommonLib>
    <summary>
      The Common PHP Class Library
    </summary>
    <remarks>
      Use this code to include the Common lib classes.
      &lt;pre&gt;
      declare(strict_types=1);
      include_once "LJCRoot.php";
      $prefix = RelativePrefix();
      include_once "$prefix/LJCPHPCommon/LJCCommonLib.php";&lt;/pre&gt;
    </remarks>
  </LJCCommonLib>
  <LJC>
    <summary>
      Contains common PHP functions
    </summary>
  </LJC>
  <!-- String Functions -->
  <CreateJSON>
    <summary>
      Creates JSON from the provided value.
    </summary>
    <param name="$value">The object value.</param>
    <returns>The JSON text.</returns>
    <code>
      // Creates JSON from the provided value.
      private static function CreateJSON()
      {
        $value = (object) [
          "Name" => "John",
          "Number" => 5,
        ];
        $result = LJC::CreateJSON($value);

        // result:
        // {"Name":"John","Number":5}";
      }
    </code>
  </CreateJSON>
  <EndsWithNewLine>
    <summary>
      Indicates if the builder text ends with a newline.
    </summary>
    <param name="$text">The text value.</param>
    <returns>true if the text ends with a newline; otherwise false.</returns>
    <code>
      // Indicates if the builder text ends with a newline.
      private static function EndsWithNewLine()
      {
        $text = "What?\r\n";
        $value = LJC::EndsWithNewLine($text);
        $result = $value ? "true" : "false";

        // result:
        // true
      }
    </code>
  </EndsWithNewLine>
  <GetDelimitedString>
    <summary>Gets the string between the delimiters.</summary>
    <param name="$text">The text to be parsed.</param>
    <param name="$beginDelimiter">The beginning delimiter.</param>
    <param name="$endDelimiter">The ending delimiter.</param>
    <param name="$lTrim">Indicates if the parsed value is to be left trimmed.</param>
    <param name="$rTrim">Indicates if the parsed value is to be right trimmed.</param>
    <returns>The parsed value.</returns>
    <remarks>
      Returns null if the begin delimiter is not found.
      &lt;br /&gt;
      &lt;br /&gt;
      Includes to the end of the string if the end delimiter is null
      or not found.
    </remarks>
    <code>
      // Gets the string between the delimiters.
      private static function GetDelimitedString()
      {
        $text = "This | here |.";
        $beginDelimiter = "|";
        $endDelimiter = "|";
        $result = LJC::GetDelimitedString($text, $beginDelimiter, $endDelimiter);

        // result:
        // here
      }
    </code>
  </GetDelimitedString>
  <GetTokens>
    <summary>
      Get string tokens.
    </summary>
    <param name="$text">The text value.</param>
    <param name="$splitString">The split string value.</param>
    <returns>The split string array.</returns>
    <code>
      // Get string tokens.
      private static function GetTokens()
      {
        $text = "Now|is|the|time.";
        $values = LJC::GetTokens($text, "/\|/");
        $result = join(", ", $values);

        // result:
        // Now, is, the, time.
      }
    </code>
  </GetTokens>
  <NewLineTrim>
    <summary>
      Removes the trailing newline from the text.
    </summary>
    <param name="$text">The text value.</param>
    <returns>The text without the trailing newline.</returns>
    <code>
      // Removes newline from text.
      private static function NewLineTrim()
      {
        $text = "Now\r\n";
        $result = LJC::NewLineTrim($text);

        // result:
        // Now

        $text = "Now\n";
        $result = LJC::NewLineTrim($text);

        // result:
        // Now
      }
    </code>
  </NewLineTrim>
  <ParseJSON>
    <summary>
      Parses JSON into an object.
    </summary>
    <param name="$json">The json text.</param>
    <returns>The created object.</returns>
    <code>
      // Parses JSON into an object.
      private static function ParseJSON()
      {
        $text = "{\"Name\":\"John\",\"Number\":5}";
        $result = LJC::ParseJSON($text);

        // result:
        $result = (object) [
          "Name" => "John",
          "Number" => 5,
        ];
      }
    </code>
  </ParseJSON>
  <Scrub>
    <summary>Returns a scrubbed external value.</summary>
    <param name="$text">The text to be scrubbed.</param>
    <returns>The scrubbed value.</returns>
    <remarks>
      Trims the text, strips slashes and converts HTML characters to HTML
      entities.
    </remarks>
    <code>
      // Returns a scrubbed external value.
      private static function Scrub()
      {
        $result = LJC::Scrub(" &amp;lt;/tag&amp;gt; ");

        // result:
        // &amp;amp;lt;/tag&amp;amp;gt;
      }
    </code>
  </Scrub>
  <Split>
    <summary>
      Splits a string on whitespace.
    </summary>
    <param name="$text">The text value.</param>
    <code>
      // Splits a string on whitespace.
      private static function Split()
      {
        $text = "Now is the time.";
        $values = LJC::Split($text);
        $result = join(", ", $values);

        // result:
        // Now, is, the, time.
      }
    </code>
  </Split>
  <StrPos>
    <summary>Gets the first index for the search value.</summary>
    <param name="$text">The text to be searched.</param>
    <param name="$find">The search value.</param>
    <param name="$start">The search start index.</param>
    <param name="$exact">Indicates if a case sensitive search is performed.</param>
    <returns>The integer index value.</returns>
    <remarks>
      The integer -1 is returned if the search value is not found.
      &lt;br /&gt;
      &lt;br /&gt;
      This alternative for PHP strpos() always returns an integer. It can be
      simply tested for success $index &gt;= 0 or failure $index &lt; 0.
    </remarks>
    <code>
      // Gets the first index for the search value.
      private static function StrPos()
      {
        $text = "This here.";
        $find = "Here";
        $index = LJC::StrPos($text, $find);
        $result = strval($index);

        // result:
        // 5

        $index = LJC::StrPos("This here.", "Here", exact: true);
        $result = strval($index);

        // result:
        // -1
      }
    </code>
  </StrPos>
  <StrRPos>
    <summary>Gets the last index for the search value.</summary>
    <param name="$text">The text to be searched.</param>
    <param name="$find">The search value.</param>
    <param name="$start">The search start index.</param>
    <param name="$exact">Indicates if a case sensitive search is performed.</param>
    <returns>The integer index value.</returns>
    <remarks>
      The integer -1 is returned if the search value is not found. It can be
      simply tested for success $index &gt;= 0 or failure $index &lt; 0.
      &lt;br /&gt;
      &lt;br /&gt;
      This alternative for PHP strpos() always returns an integer.
    </remarks>
    <code>
      // Gets the last index for the search value.
      private static function StrRPos()
      {
        $text = "This here is here.";
        $find = "Here";
        $index = LJC::StrRPos($text, $find);
        $result = strval($index);

        // result:
        // 13

        $index = LJC::StrPos("This here.", "Here", exact: true);
        $result = strval($index);

        // result:
        // -1
      }
    </code>
  </StrRPos>
  <!-- File Name Functions -->
  <GetFileName>
    <summary>Gets the FileName from the file spec.</summary>
    <param name="$fileSpec">The file specification.</param>
    <returns>The file name.</returns>
    <remarks>
      Parses from the last "/" to the following ".".
      &lt;br /&gt;
      &lt;br /&gt;
      Includes to the end of the string if the "." is not found.
    </remarks>
    <code>
      // Gets the FileName from the file spec.
      private static function GetFileName()
      {
        $fileSpec = "../Folder/File.txt";
        $result = LJC::GetFileName($fileSpec);

        // result:
        // File;
      }
    </code>
  </GetFileName>
  <GetFileSpecPath>
    <summary>Gets the Path from the file spec.</summary>
    <param name="$fileSpec">The file specification.</param>
    <returns>The file path.</returns>
    <remarks>
      Parses to the last "/".
    </remarks>
    <code>
      // Gets the Path from the file spec.
      private static function GetFileSpecPath()
      {
        $fileSpec = "../Folder/File.txt";
        $result = LJC::GetFileSpecPath($fileSpec);

        // result:
        // ../Folder
      }
    </code>
  </GetFileSpecPath>
  <!-- Check Value Functions -->
  <HasElements>
    <summary>
      Checks for array elements.
    </summary>
    <param name="$array">The array object.</param>
    <code>
      // Checks for array elements.
      private static function HasElements()
      {
        $array = [];
        $value = LJC::HasElements($array);
        $result = $value ? "true" : "false";

        // result:
        // false
      }
    </code>
    <returns>
      true if the object is an array and has elements; otherwise false.
    </returns>
  </HasElements>
  <HasItems>
    <summary>
      Checks for collection items.
    </summary>
    <param name="$collection">The collection object.</param>
    <returns>
      true if the object is a collection and has items; otherwise false.
    </returns>
    <code>
      class Names extends LJCCollectionBase
      {
        public function Add(string $text)
        {
          $this->AddItem($text);
        }

        public string $Name;
      }

      // Checks for collection items.
      private static function HasItems()
      {
        $names = new Names();
        $names->Add("First");

        $value = LJC::HasItems($names);
        $result = $value ? "true" : "false";

        // result:
        // true
      }
    </code>
  </HasItems>
  <HasValue>
    <summary>
      Checks for text.
    </summary>
    <param name="$text">The text value.</param>
    <returns>
      true if the text has other than white space; otherwise false;
    </returns>
    <code>
      // Checks for text.
      private static function HasValue()
      {
        $text = "Text";
        $value = LJC::HasValue($text);
        $result = $value ? "true" : "false";

        // result:
        // true
      }
    </code>
  </HasValue>
  <HasXML>
    <summary>
      Checks an XML element for a value.
    </summary>
    <param name="$xmlElement">The simple xml element.</param>
    <returns>
      true if the element text has other than white space; otherwise false;
    </returns>
    <code>
      // Checks an XML element for a value.
      private static function HasXML()
      {
        $xml = new SimpleXMLElement("<name>Name</name>");
        $string = LJC::XMLToString($xml);
        $value = LJC::HasXML($xml);
        $result = $value ? "true" : "false";

        // result:
        // true
      }
    </code>
  </HasXML>
  <!-- Array Functions -->
  <RemoveString>
    <summary>
      Remove an element from a string array by value.
    </summary>
    <param name="$array">The array object.</param>
    <param name="$value">The string value.</param>
    <code>
      // Remove element from string array by value.
      private static function RemoveString()
      {
        $array = ["First", "Second", "Third"];
        LJC::RemoveString($array, "Second");
        $result = join(" ", $array);

        // result:
        // First Third
      }
    </code>
  </RemoveString>
  <!-- Convert Functions -->
  <ToArray>
    <summary>
      Copy collection items to an indexed array.
    </summary>
    <param name="$items">The collection object.</param>
    <code>
      class Names extends LJCCollectionBase
      {
        public function Add(string $text)
        {
          $this->AddItem($text);
        }

        public string $Name;
      }

      // Copy collection items to an indexed array.
      private static function ToArray()
      {
        $names = new Names();
        $names->Add("First");
        $array = LJC::ToArray($names);
        $result = $array[0];

        // result:
        // First
      }
    </code>
  </ToArray>
  <ToBool>
    <summary>
      Returns a value as bool.
    </summary>
    <param name="$value">The object value.</param>
    <returns>The bool value.</returns>
    <code>
      // Returns a value as bool.
      private static function ToBool()
      {
        $text = "false";
        $value = LJC::ToBool($text);
        $result = $value ? "true" : "false";

        // result:
        // false
      }
    </code>
  </ToBool>
  <ToBoolInt>
    <summary>
      Returns a text value as an int boolean.
    </summary>
    <param name="$text">The text value.</param>
    <returns>The int bool value.</returns>
    <code>
      // Returns a text value as int boolean.
      private static function ToBoolInt()
      {
        $text = "false";
        $value = LJC::ToBoolInt($text);
        $result = strval($value);

        // result:
        // 0
      }
    </code>
  </ToBoolInt>
  <XMLToString>
    <summary>
      Gets a string value from the XML element.
    </summary>
    <param name="$xmlValue">The XML element.</param>
    <param name="$trim">Indicates if the values should be trimmed.</param>
    <returns>The XML string content value.</returns>
    <code>
      // Gets a string value from the XML value.
      private static function XMLToString()
      {
        $xml = new SimpleXMLElement("<name>Name</name>");
        $result = LJC::XMLToString($xml);

        // result:
        // Name
      }
    </code>
  </XMLToString>
  <!-- Output Functions -->
  <OutputLogCompare>
    <summary>
      Outputs the test compare text.
    </summary>
    <param name="$methodName">The debug method name.</param>
    <param name="$result">The result value.</param>
    <param name="$compare">The compare to value.</param>
    <param name="$bracket">The optional bracket flag.</param>
    <code>
      // Outputs the test compare text.
      private static function OutputLogCompare()
      {
        $methodName = "OutputLogCompare()";

        $result = "Test";

        $compare = "Test";
        $output = LJC::OutputLogCompare($methodName, $result, $compare
          , output: false);

        // output:

        $compare = "Te st";
        $output = LJC::OutputLogCompare($methodName, $result, $compare
          , output: false);
  
        // output:
        //
        // OutputLogCompare()
        // Test
        //  !=
        // Te st
      }
    </code>
  </OutputLogCompare>
  <HasDiff>
    <summary>
      Checks if two strings are different.
    </summary>
    <param name="$result">The result value.</param>
    <param name="$compare">The compare to value.</param>
    <returns>true if the strings are different; otherwise false.</returns>
    <code>
      // Checks if two strings are different.
      private static function HasDiff()
      {
        $result = "This is the first line.\n";
        $result .= "This is the second line.\n";

        $compare = "This is the first line.\n";
        $compare .= "This is the second line.\n";
        if (LJC::HasDiff($result, $compare))
        {
          echo("\r\n\r\nHasDiff()");
          LJC::ShowFirstDiff($result, $compare);
        }
      }
    </code>
  </HasDiff>
  <ShowFirstDiff>
    <summary>
      Shows the first difference between two strings.
    </summary>
    <param name="$result">The result value.</param>
    <param name="$compare">The compare to value.</param>
    <code>
      // Shows the first difference between two strings.
      private static function ShowFirstDiff()
      {
        $result = "This is the first line.\n";
        $result .= "This is the second line.\n";

        $compare = "This is the first line.\n";
        $compare .= "This is the second line.\n";
        if (LJC::HasDiff($result, $compare))
        {
          echo("\r\n\r\nShowFirstDiff()");
          LJC::ShowFirstDiff($result, $compare);
        }
      }
    </code>
  </ShowFirstDiff>
  <ShowWhiteSpace>
    <summary>
      Returns a string that shows the whitespace.
    </summary>
    <param name="$text">The text value.</param>
    <code>
      // Returns a string that shows the whitespace.
      private static function ShowWhiteSpace()
      {
        $result = LJC::ShowWhiteSpace("This is a line.\n");

        $compare = "This is a line.\\n";
        LJC::OutputLogCompare("ShowWhiteSpace()", $result, $compare);
      }
    </code>
  </ShowWhiteSpace>
  <!-- Output Class Functions -->
  <OutputConstruct>
    <summary>
      Initializes a class instance with the provided values.
    </summary>
    <param name="$className">The source class name.</param>
  </OutputConstruct>
  <GetLogText>
    <summary>
      Gets the object debug text.
    </summary>
    <param name="$location">The debug location.</param>
    <param name="$value">The value.</param>
    <param name="$bracket">The optional bracket flag.</param>
    <code>
      // Gets the object debug text.
      private static function GetLogObjectText()
      {
        $className = "CommonTest";
        $methodName = "GetLogObjectText";
        $valueName = "\$value";
        $location = LJC::Location($className, $methodName, $valueName);

        // Example Method
        $object = "Test";
        $result = LJC::GetLogObjectText($location, $object);

        // result;
        //
        // CommonTest.GetLogObjectText $value:
        // Test
      }
    </code>
  </GetLogText>
  <Location>
    <summary>
      Gets the location string.
    </summary>
    <param name="$className">The debug class name.</param>
    <param name="$methodName">The debug method name.</param>
    <param name="$valueName">The value name.</param>
    <code>
      // Gets the location string.
      private static function Location()
      {
        $className = "CommonTest";
        $methodName = "GetLogObjectText";
        $valueName = "\$value";
        $result = LJC::Location($className, $methodName, $valueName);

        // result:
        // CommonTest.GetLogObjectText $value:
      }
    </code>
  </Location>
  <OutputLog>
    <summary>
      Outputs the debug text.
    </summary>
    <param name="$lineNumber">The debug line number.</param>
    <param name="$valueName">The value name.</param>
    <param name="$value">The value.</param>
    <code>
      // Outputs the value debug text.
      private static function OutputLog()
      {
        $methodName = "OutputLog";

        $valueName = "\$value";
        $value = "Test";
        $lineNumber = __line__;
        $output = LJC::OutputLog($lineNumber, $valueName, $value, output: false);

        // output:
        //
        // 123 $value = Test
      }
    </code>
  </OutputLog>
  <OutputLogObject>
    <summary>
      Outputs the object debug text.
    </summary>
    <param name="$lineNumber">The debug line number.</param>
    <param name="$className">The debug class name.</param>
    <param name="$methodName">The debug method name.</param>
    <param name="$valueName">The value name.</param>
    <param name="$value">The value.</param>
    <param name="$bracket">The optional bracket flag.</param>
    <code>
      // Outputs the object debug text.
      private static function OutputLogObject()
      {
        $className = "CommonTest";
        $methodName = "OutputLogObject";
        $valueName = "\$value";
        $value = "Test";
        $output = LJC::OutputLogObject(__line__, $className, $methodName, $valueName
          , $value, isObject: false, output: false);

        // output:
        //
        // CommonTest.OutputLogObject $value: Test

        $value = (object) [
          "Name" => "John",
          "Number" => 5,
        ];
        $output = LJC::OutputLogObject(__line__, $className, $methodName, $valueName
          , $value, output: false);

        // output:
        //
        // CommonTest.OutputLogObject $value:
        // stdClass Object
        // (
        //     [Name] => John
        //     [Number] => 5
        // )
      }
    </code>
  </OutputLogObject>
  <GetIndexedDebugFileName>
    <summary>Gets the indexed Debug file name.</summary>
    <param name="$folder">The folder name.</param>
    <param name="$fileName">The file name.</param>
    <returns>The indexed Debug file spec.</returns>
    <remarks>
      This function takes a folder name and a file name. It makes sure the
      folder exists and returns the text "folder/fileName$index" with the
      extension "txt".
      &lt;br /&gt;
      &lt;br /&gt;
      The variable $index in the example file name indicates a unique index
      value that does not already exist on disk. It begins checking with an
      index value of 1.
    </remarks>
    <code>
      $result = LJCCommon::GetIndexedDebugFileName("Debug", "SourceFile.php");

      // result:
      // Debug\SourceFile1.txt
    </code>
  </GetIndexedDebugFileName>
  <SetSessionValue>
    <summary>Assigns a session value and returns the value.</summary>
    <param name="$name">The session value name.</param>
    <param name="$value">The session value.</param>
    <returns>The session value.</returns>
    <code>
      $result = LJCCommon::SetSessionValue("dbServer", "localhost");

      // result:
      // localhost
    </code>
  </SetSessionValue>
  <GetDebugFileName>
    <summary>Gets the Debug file name.</summary>
    <param name="$folder">The folder name.</param>
    <param name="$fileName">The file name.</param>
    <returns>The Debug file spec.</returns>
    <remarks>
      This function takes a folder name and a file name. It makes sure the
      folder exists and returns the text "folder/fileName" with the extension
      "txt".
    </remarks>
    <code>
      $result = LJC::GetDebugFileName("Debug", "SourceFile.php");

      // result:
      // Debug\SourceFile.txt
    </code>
  </GetDebugFileName>
</items>
